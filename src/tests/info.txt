const functions = require('@google-cloud/functions-framework');
const ffmpeg = require('fluent-ffmpeg');
const path = require('path');
const fs = require('fs');
const axios = require('axios')
// const {v4} = require('uuid')
// const { Storage } = require('@google-cloud/storage');

const TEMP_DIR = path.resolve('/tmp');

// Ensure the directory exists
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR);
}

// const GC_PRIVATE_KEY=""
// const GC_EMAIL=""
// const GC_PROJECT_ID=""
// const GC_VIDEO_BUCKET_NAME = "

// const storage = new Storage({
//   projectId: GC_PROJECT_ID,
//   credentials: {
//     client_email: GC_EMAIL,
//     private_key: GC_PRIVATE_KEY.split(String.raw`\n`).join('\n'),
//   }
// });

// async function uploadFileToGCS(filePath, fileName) {
//   // Create a reference to the file in the bucket
//   const file = storage.bucket(GC_VIDEO_BUCKET_NAME).file(fileName);

//   // Read the file content
//   const fileContent = fs.readFileSync(filePath);

//   fs.unlinkSync(finalOutputPath);

//   // Upload the file
//   await file.save(fileContent, {
//     contentType: 'video/mp4', // Adjust contentType as needed
//   });
// }

async function downloadFont(fontUrl) {
  const fontName = fontUrl.split("/").pop() ?? "fontName.ttf"; // Font name
  const fontPath = path.join(TEMP_DIR, fontName); // Path to save the font

  const response = await axios({
    url: fontUrl,
    method: 'GET',
    responseType: 'arraybuffer' // Ensure response is treated as binary
  });

  if (response.status !== 200) {
    throw new Error(`Failed to download font: ${response.statusText}`);
  }

  // Save the font to the temporary directory
  fs.writeFileSync(fontPath, Buffer.from(response.data));
}

functions.http('generateVideo', async (req, res) => {
  try {
    const { audioBase64, textFilters, footageUrl, videoLength, fontUrl } = req.body;
    
    // Validate inputs
    if (!audioBase64 || !textFilters || !footageUrl || !videoLength || !fontUrl) {
      return res.status(400).json({ error: 'Missing required parameters' });
    }

    await downloadFont(fontUrl)

    const audioBuffer = Buffer.from(audioBase64, 'base64');
    const audioPath = path.join(TEMP_DIR, 'audio.mp3');
    fs.writeFileSync(audioPath, audioBuffer);
    const outputPath = path.join(TEMP_DIR, 'output.mp4');
    const finalOutputPath = path.join(TEMP_DIR, 'final_output.mp4');

    ffmpeg.ffprobe(footageUrl, (err, metadata) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      const videoDuration = metadata.format.duration;
      if (!videoDuration) {
        return res.status(500).json({ error: 'Video duration not found' });
      }
      const maxStartTime = videoDuration - videoLength;
      const startTime = Math.random() * maxStartTime;

      ffmpeg(footageUrl)
        .setStartTime(startTime)
        .setDuration(videoLength)
        .videoFilters(`crop=ih*9/16:ih,${textFilters.join(',')}`)
        .outputOptions('-an')
        .output(outputPath)
        .on('end', () => {
          ffmpeg(outputPath)
            .addInput(audioPath)
            .outputOptions('-c:v copy')
            .output(finalOutputPath)
            .on('end', () => {
              try {
                fs.unlinkSync(audioPath);
                fs.unlinkSync(outputPath);

                const videoBuffer = fs.readFileSync(finalOutputPath);
                const base64Video = videoBuffer.toString('base64');
                const videoUrl = `data:video/mp4;base64,${base64Video}`;

                fs.unlinkSync(finalOutputPath);

                res.status(200).json({ error: null, videoUrl });
              } catch (error) {
                res.status(500).json({ error: error.message });
              }
            })
            .on('error', (err) => {
              fs.unlinkSync(audioPath);
              res.status(500).json({ error: err.message });
            })
            .run();
        })
        .on('error', (err) => {
          fs.unlinkSync(audioPath);
          res.status(500).json({ error: err.message });
        })
        .run();
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
